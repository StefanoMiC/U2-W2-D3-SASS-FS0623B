// 1) variabili  SCSS

// la keword !default definisce un valore iniziale che verrÃ  applicato solo nel caso in cui non esista una definizione precedente
// se definiamo un $color-primary prima dell'import di questo file, il $color-primary qui di seguito non applicherÃ  il suo valore
$main-font: "Franklin Gothic Medium", "Arial Narrow", Arial, sans-serif !default;
$main-color: rgb(230, 0, 255) !default;
$danger-color: rgb(255, 30, 0) !default;
$warning-color: rgb(255, 225, 0) !default;
$success-color: rgb(4, 255, 0) !default;

// 2) NESTING - Selettori annidati (o nidificati)
body {
  margin: 0;

  // creazione di proprietÃ  composte
  font: {
    family: $main-font;
    weight: 400;
    size: 1rem;
    style: normal;
  }
}
// selettori vuoti non verranno compilati nella versione finale
// section {
// }

// mentre errori, impediscono la ri-generazione del foglio css compilato (il browser non riceverÃ  le ultime modifiche, fino alla risoluzione degli errori)
// div } - o qualsiasi altro tipo di errore di sintassi.

// da questo momento potreste usare una struttura annidata per lavorare in maniera piÃ¹ efficente e controllata
main {
  padding-inline: 3rem;
  section {
    //parent selector ==> &

    h1 {
      color: $main-color;
      transition: background-color 0.3s;

      &:hover {
        background-color: lightgreen;
      }
    }

    div {
      // &:nth-of-type(2) {
      // }
      // &:nth-of-type(3) {
      // }
      // &:nth-of-type(4) {
      // }

      ul {
        li {
          color: blue;

          //parent selector ==> &
          &::marker {
            content: "ðŸ¤©ðŸ¥¶";
          }
        }
      }
    }
  }
}
// questo si compilerÃ  in questo modo:
// main section h1 {
// }

// 3) Parent Selector (&) - permette di riferirsi al genitore in questo contesto, senza ripetere il suo nome piÃ¹ volte
.btn {
  background-color: transparent;
  border: 1px solid transparent;
  padding: 0.25rem 0.5rem;
  border-radius: 6px;
  color: inherit;
  font-family: inherit;
  font-weight: inherit;

  // 3) Parent Selector (&) - permette di riferirsi al genitore in questo contesto, senza ripetere il suo nome piÃ¹ volte
  &-primary {
    // background-color: lighten($main-color, 30%);
    background-color: scale-color($main-color, $lightness: 50%);
    border-color: $main-color;
    color: scale-color($main-color, $lightness: -60%);
  }
  &-success {
    background-color: scale-color($success-color, $lightness: 50%);
    border-color: $success-color;
    color: scale-color($success-color, $lightness: -60%);
  }
  &-warning {
    background-color: scale-color($warning-color, $lightness: 50%);
    border-color: $warning-color;
    color: scale-color($warning-color, $lightness: -60%);
  }
  &-danger {
    background-color: scale-color($danger-color, $lightness: 50%);
    border-color: $danger-color;
    color: scale-color($danger-color, $lightness: -60%);
  }

  // media queries annidate nel selettore
  @media screen and (min-width: 768px) {
    padding: 0.5rem 1.5rem;
  }
  @media screen and (min-width: 992px) {
    padding: 1rem 3rem;
  }
}

@mixin myBox($mainColor: lightgray, $borderColor: gray, $textColor: black, $radius: 10px) {
  // parametro: defaultValue
  // un parametro senza default dovrÃ  ricevere per forza un valore, altrimenti SASS darÃ  un errore di compilazione
  // quando un parametro specifica un default si puÃ² omettere di passargli un valore. lui acquisirÃ  il valore specificato come default in quel caso
  width: 200px;
  height: 200px;
  margin-block: 2rem;
  display: inline-block;
  vertical-align: bottom;
  border-radius: $radius;
  border: 2px solid $borderColor;
  color: $textColor;
  background-color: $mainColor;
  box-shadow: 0 3px 30px scale-color($mainColor, $blackness: 30%);
}

@mixin dynamicSquare($size, $val, $propertyName) {
  width: $size;
  height: $size;
  margin-block: 2rem;
  vertical-align: bottom;

  border: 2px solid lightcoral;
  color: black;
  // interpolazione di valore #{}
  // in JS l'interpolazione di stringa si faceva con: `${nomeVar} piÃ¹ altre cose...`
  background-#{$propertyName}: $val;

  @if ($propertyName == "image") {
    display: inline-block;
    background-size: cover;
    background-repeat: no-repeat;
  } @else {
    display: inline-flex;
    justify-content: center;
    align-items: center;
  }
}

// 4) EXTEND (@extend) - Ã¨ in grado di riprendere tutto un blocco precedente di una classe / id / elemento
.btn-alt {
  @extend .btn;

  padding: 1rem;
  border-width: 2px;
  border-radius: 10px;
  background-color: palegoldenrod;
  border-color: rgb(168, 154, 0);
  color: rgb(33, 31, 1);
}

// 5) PLACEHOLDER (%)- serve ad incorporare un blocco CSS che rispetto ad estendere da selettori esistenti, questo non esisterÃ  di per sÃ©
// ci permette di dichiarare dei blocchi di regole css e richiamarli all'occorrenza in selettori che verranno poi generati nel css finale.

// il blocco del placeholder da solo "non esiste"

%reset-btn {
  border: none;
  background-color: transparent;
  color: inherit;
}

%reset-font {
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.btn-basic {
  @extend %reset-btn, %reset-font;
}

// 6) MIXINS - un blocco di codice CSS che puÃ² generarsi anche con valori (o parametri) dinamici

.box-1 {
  @include myBox(darkblue, darkcyan, paleturquoise, 10px);
}
.box-2 {
  @include myBox(crimson, coral, palegoldenrod, 30px);
}
.box-3 {
  @include myBox(); // internamente al mixin verranno usati i valori di default
}
.box-4 {
  @include myBox($radius: 60px, $borderColor: rgb(148, 140, 240));
  // internamente al mixin verranno usati i valori di default,
  //tranne per i due che abbiamo passato richiamando il nome della variabile di parametro
  // in questo modo possiamo anche passare i parametri in ordine sparso
}

.box-5 {
  @include dynamicSquare(
    300px,
    url("https://plus.unsplash.com/premium_photo-1700838996452-9e83d1f2c514?q=80&w=2072&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"),
    "image"
  );
}

.box-6 {
  @include dynamicSquare(300px, darkcyan, "color");
}

// 9) CICLI

// CICLO FOR

// @for $contatore from 0 to 5  ==> dove <start> to <end> "to" rappresenta il valore con <end> ESCLUSO, come un <
// @for $contatore from 0 through 5  ==> dove <start> through <end> "through" rappresenta il valore con <end> INCLUSO, come un <=

@for $i from 1 through 5 {
  .custom-padding-#{$i} {
    padding: $i * 10px;
  }
}

// CICLO EACH

// @each $elem in red, green, blue, yellow, purple, orange {
//   .square-#{$elem} {
//     background-color: $elem;
//   }
// }

// datatype List
$colorKeys: red, green, blue, yellow, purple, orange;

// la variabile $elem acquisirÃ  come valore uno dei colori della lista, uno dopo l'altro
@each $elem in $colorKeys {
  .square-#{$elem} {
    background-color: $elem;
  }
}

// datatype Map

$sizes: (
  xs: 10px,
  sm: 20px,
  md: 30px,
  lg: 60px,
  xl: 120px,
  xxl: 200px
);

// nel caso delle mappe ci servono due variabili, una per la chiave e una per il valore degli elementi della mappa

// n.b. se usassimo un solo valore chiamato $elem per esempio, saremmo solo in grado di ricevere la chiave e non avremmo accesso al valore
@each $key, $val in $sizes {
  .padding-#{$key} {
    padding: $val;

    // questo genererÃ  4 classi con padding-*-inline
    &-inline {
      padding-inline: $val;
    }
    // questo genererÃ  4 classi con padding-*-block
    &-block {
      padding-block: $val;
    }
  }
}
